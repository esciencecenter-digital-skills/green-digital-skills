[{"data":1,"prerenderedAt":684},["ShallowReactive",2],{"content-query-E4leBsHYEO":3,"content-query-AT44bg6JPw":600},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"type":10,"order":11,"body":12,"_type":594,"_id":595,"_source":596,"_file":597,"_extension":598,"plainText":599},"/modules/hpc-handson/exercises","hpc-handson",false,"","Exercises","Choose an application from the list below","exercise",6,{"type":13,"children":14,"toc":577},"root",[15,23,36,43,49,55,62,74,137,142,148,164,169,176,178,262,274,279,284,308,347,358,369,374,388,399,404,416,437,450,463,474,483,494,502,513,521,526,546,554,559,567],{"type":16,"tag":17,"props":18,"children":20},"element","h1",{"id":19},"exercises",[21],{"type":22,"value":8},"text",{"type":16,"tag":24,"props":25,"children":26},"p",{},[27,29],{"type":22,"value":28},"Choose an application from the list ",{"type":16,"tag":30,"props":31,"children":33},"a",{"href":32},"#applications",[34],{"type":22,"value":35},"below",{"type":16,"tag":37,"props":38,"children":40},"h3",{"id":39},"_1-monitor-an-application-with-ear",[41],{"type":22,"value":42},"1. Monitor an application with EAR",{"type":16,"tag":37,"props":44,"children":46},{"id":45},"_2-identify-whether-the-applicaiton-is-cpu-intensive-or-memorycommunication-intensive",[47],{"type":22,"value":48},"2. Identify whether the applicaiton is CPU intensive or Memory/Communication intensive",{"type":16,"tag":37,"props":50,"children":52},{"id":51},"_3-play-with-pytorch-automatic-mixed-precision-and-maybe-model-size-what-impacts-on-energy-does-this-have",[53],{"type":22,"value":54},"3. Play with PyTorch Automatic Mixed Precision, and maybe model \"size\". What impacts on Energy does this have?",{"type":16,"tag":56,"props":57,"children":59},"h2",{"id":58},"applications",[60],{"type":22,"value":61},"Applications",{"type":16,"tag":24,"props":63,"children":64},{},[65,67],{"type":22,"value":66},"All of the Applications used in this tutorial can be found in the project space ",{"type":16,"tag":68,"props":69,"children":71},"code",{"className":70},[],[72],{"type":22,"value":73},"/projects/0/energy-course/",{"type":16,"tag":75,"props":76,"children":77},"ol",{},[78,88],{"type":16,"tag":79,"props":80,"children":81},"li",{},[82],{"type":16,"tag":30,"props":83,"children":85},{"href":84},"#synthetic-applications",[86],{"type":22,"value":87},"Synthetic Applications",{"type":16,"tag":79,"props":89,"children":90},{},[91,97],{"type":16,"tag":30,"props":92,"children":94},{"href":93},"#scientific-applications",[95],{"type":22,"value":96},"Scientific Applications",{"type":16,"tag":98,"props":99,"children":100},"ul",{},[101,110,119,128],{"type":16,"tag":79,"props":102,"children":103},{},[104],{"type":16,"tag":30,"props":105,"children":107},{"href":106},"#hemepure",[108],{"type":22,"value":109},"HemePure",{"type":16,"tag":79,"props":111,"children":112},{},[113],{"type":16,"tag":30,"props":114,"children":116},{"href":115},"#palabos",[117],{"type":22,"value":118},"Palabos",{"type":16,"tag":79,"props":120,"children":121},{},[122],{"type":16,"tag":30,"props":123,"children":125},{"href":124},"#gromacs",[126],{"type":22,"value":127},"GROMACS",{"type":16,"tag":79,"props":129,"children":130},{},[131],{"type":16,"tag":30,"props":132,"children":134},{"href":133},"#pytorch",[135],{"type":22,"value":136},"PyTorch",{"type":16,"tag":56,"props":138,"children":140},{"id":139},"synthetic-applications",[141],{"type":22,"value":87},{"type":16,"tag":37,"props":143,"children":145},{"id":144},"nas-parallel-benchmarks-npb34-mz-mpiopenmp-sp-mz-benchmark",[146],{"type":22,"value":147},"NAS Parallel Benchmarks (NPB3.4-MZ MPI+OpenMP) - SP-MZ Benchmark",{"type":16,"tag":149,"props":150,"children":151},"blockquote",{},[152],{"type":16,"tag":24,"props":153,"children":154},{},[155,157],{"type":22,"value":156},"The NAS Parallel Benchmarks (NPB) are a small set of programs designed to help evaluate the performance of parallel supercomputers. The benchmarks are derived from computational fluid dynamics (CFD) applications ",{"type":16,"tag":30,"props":158,"children":162},{"href":159,"rel":160},"https://www.nas.nasa.gov/software/npb.html",[161],"nofollow",[163],{"type":22,"value":159},{"type":16,"tag":24,"props":165,"children":166},{},[167],{"type":22,"value":168},"In this course we will use the \"Multi-zone versions of NPB\" (NPB-MZ). These are designed to exploit multiple levels of parallelism in applications and to test the effectiveness of multi-level and hybrid parallelization (MPI-OpenMP) paradigms and tools. Specifically we use the SP-MZ (even-size zones within a problem class, increased number of zones as problem class grows).",{"type":16,"tag":170,"props":171,"children":173},"h5",{"id":172},"problem-sizes",[174],{"type":22,"value":175},"Problem Sizes:",{"type":22,"value":177},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":16,"tag":179,"props":180,"children":181},"table",{},[182,211],{"type":16,"tag":183,"props":184,"children":185},"thead",{},[186],{"type":16,"tag":187,"props":188,"children":189},"tr",{},[190,196,201,206],{"type":16,"tag":191,"props":192,"children":193},"th",{},[194],{"type":22,"value":195},"Class",{"type":16,"tag":191,"props":197,"children":198},{},[199],{"type":22,"value":200},"Mesh size (x)",{"type":16,"tag":191,"props":202,"children":203},{},[204],{"type":22,"value":205},"Mesh size (y)",{"type":16,"tag":191,"props":207,"children":208},{},[209],{"type":22,"value":210},"Mesh size (z)",{"type":16,"tag":212,"props":213,"children":214},"tbody",{},[215,239],{"type":16,"tag":187,"props":216,"children":217},{},[218,224,229,234],{"type":16,"tag":219,"props":220,"children":221},"td",{},[222],{"type":22,"value":223},"C",{"type":16,"tag":219,"props":225,"children":226},{},[227],{"type":22,"value":228},"240",{"type":16,"tag":219,"props":230,"children":231},{},[232],{"type":22,"value":233},"320",{"type":16,"tag":219,"props":235,"children":236},{},[237],{"type":22,"value":238},"28",{"type":16,"tag":187,"props":240,"children":241},{},[242,247,252,257],{"type":16,"tag":219,"props":243,"children":244},{},[245],{"type":22,"value":246},"D",{"type":16,"tag":219,"props":248,"children":249},{},[250],{"type":22,"value":251},"1632",{"type":16,"tag":219,"props":253,"children":254},{},[255],{"type":22,"value":256},"1216",{"type":16,"tag":219,"props":258,"children":259},{},[260],{"type":22,"value":261},"34",{"type":16,"tag":24,"props":263,"children":264},{},[265,267],{"type":22,"value":266},"Example jobscript\n",{"type":16,"tag":30,"props":268,"children":271},{"href":269,"target":270},"/modules/hpc-handson/scripts/NPB_job.sh","_blank",[272],{"type":22,"value":273},"NPB_job.sh",{"type":16,"tag":56,"props":275,"children":277},{"id":276},"scientific-applications",[278],{"type":22,"value":96},{"type":16,"tag":37,"props":280,"children":282},{"id":281},"hemepure",[283],{"type":22,"value":109},{"type":16,"tag":149,"props":285,"children":286},{},[287],{"type":16,"tag":24,"props":288,"children":289},{},[290,292,298,302],{"type":22,"value":291},"HemePure/HemeLB developed by the team of Prof Peter Coveney at University College London (UCL), is a software pipeline that simulates blood flow. HemePure is specifically designed to efficiently handle sparse topologies, supports real-time visualization and remote steering of the simulation and can handle fully resolved realistic vessels like those found in the human brain. ",{"type":16,"tag":30,"props":293,"children":296},{"href":294,"rel":295},"https://github.com/UCL-CCS/HemePure",[161],[297],{"type":22,"value":294},{"type":16,"tag":299,"props":300,"children":301},"br",{},[],{"type":16,"tag":30,"props":303,"children":306},{"href":304,"rel":305},"https://github.com/UCL-CCS/HemePure-GPU",[161],[307],{"type":22,"value":304},{"type":16,"tag":98,"props":309,"children":310},{},[311],{"type":16,"tag":79,"props":312,"children":313},{},[314,316,322,324,329,331,337,339,345],{"type":22,"value":315},"The executables are located in the directory ",{"type":16,"tag":68,"props":317,"children":319},{"className":318},[],[320],{"type":22,"value":321},"/projects/0/energy-course/HemePure",{"type":22,"value":323},". There you will find the ",{"type":16,"tag":68,"props":325,"children":327},{"className":326},[],[328],{"type":22,"value":281},{"type":22,"value":330}," and ",{"type":16,"tag":68,"props":332,"children":334},{"className":333},[],[335],{"type":22,"value":336},"hemepure_gpu",{"type":22,"value":338}," (CUDA enabled) exectubles.\n",{"type":16,"tag":340,"props":341,"children":342},"strong",{},[343],{"type":22,"value":344},"How to run a case",{"type":22,"value":346},"\nWe will be running through an example of pressure driven flow through a bifurcation available in the HemeLB download.",{"type":16,"tag":24,"props":348,"children":349},{},[350,352],{"type":22,"value":351},"CPU example jobscript\n",{"type":16,"tag":30,"props":353,"children":355},{"href":354,"target":270},"/modules/hpc-handson/scripts/HemePure_CPU_job.sh",[356],{"type":22,"value":357},"hemepure_cpu_job.sh",{"type":16,"tag":24,"props":359,"children":360},{},[361,363],{"type":22,"value":362},"GPU example jobscript\n",{"type":16,"tag":30,"props":364,"children":366},{"href":365,"target":270},"/modules/hpc-handson/scripts/HemePure_GPU_job.sh",[367],{"type":22,"value":368},"hemepure_gpu_job.sh",{"type":16,"tag":37,"props":370,"children":372},{"id":371},"palabos",[373],{"type":22,"value":118},{"type":16,"tag":149,"props":375,"children":376},{},[377],{"type":16,"tag":24,"props":378,"children":379},{},[380,382],{"type":22,"value":381},"The Palabos (Parallel Lattice Boltzmann Solver) library is a framework for general-purpose computational fluid dynamics (CFD), with a kernel based on the lattice Boltzmann method. The case we use in this course is a simulation of blood flow in a inside the 3D aneurysm geometry. ",{"type":16,"tag":30,"props":383,"children":386},{"href":384,"rel":385},"https://palabos.unige.ch/",[161],[387],{"type":22,"value":384},{"type":16,"tag":24,"props":389,"children":390},{},[391,393],{"type":22,"value":392},"example jobscript\n",{"type":16,"tag":30,"props":394,"children":396},{"href":395,"target":270},"/modules/hpc-handson/scripts/Palabos_job.sh",[397],{"type":22,"value":398},"palabos_job.sh",{"type":16,"tag":37,"props":400,"children":402},{"id":401},"gromacs",[403],{"type":22,"value":127},{"type":16,"tag":149,"props":405,"children":406},{},[407],{"type":16,"tag":24,"props":408,"children":409},{},[410,414],{"type":16,"tag":340,"props":411,"children":412},{},[413],{"type":22,"value":127},{"type":22,"value":415}," A free and open-source software suite for high-performance molecular dynamics and output analysis.",{"type":16,"tag":149,"props":417,"children":418},{},[419],{"type":16,"tag":24,"props":420,"children":421},{},[422,427,429,435],{"type":16,"tag":340,"props":423,"children":424},{},[425],{"type":22,"value":426},"The HECBioSim Benchmarks:",{"type":22,"value":428}," (",{"type":16,"tag":30,"props":430,"children":433},{"href":431,"rel":432},"https://www.hecbiosim.ac.uk/access-hpc/benchmarks",[161],[434],{"type":22,"value":431},{"type":22,"value":436},")",{"type":16,"tag":149,"props":438,"children":439},{},[440],{"type":16,"tag":24,"props":441,"children":442},{},[443,448],{"type":16,"tag":340,"props":444,"children":445},{},[446],{"type":22,"value":447},"HECBioSim benchmark suite",{"type":22,"value":449}," consists of a set of simple benchmarks for a number of popular Molecular Dynamics (MD) engines, each of which is set at a different atom count. The benchmark suite currently contains benchmarks for the AMBER, GROMACS, LAMMPS and NAMD molecular dynamics packages.",{"type":16,"tag":24,"props":451,"children":452},{},[453,455,461],{"type":22,"value":454},"In this example we will choose the \"465K atom system - hEGFR Dimer of 1IVO and 1NQL\" simulation (which can be found here ",{"type":16,"tag":30,"props":456,"children":459},{"href":457,"rel":458},"https://github.com/victorusu/GROMACS_Benchmark_Suite/tree/1.0.0/HECBioSim/hEGFRDimer",[161],[460],{"type":22,"value":457},{"type":22,"value":462},"). This simulation contains a total number of atoms = 465,399 (Protein atoms = 21,749  Lipid atoms = 134,268  Water atoms = 309,087  Ions = 295). The run will take about 10 minutes to execute (using all 128 cores of an AMD ROME node). The image below shows the simulation that we will run.",{"type":16,"tag":98,"props":464,"children":465},{},[466],{"type":16,"tag":79,"props":467,"children":468},{},[469],{"type":16,"tag":340,"props":470,"children":471},{},[472],{"type":22,"value":473},"20K atom system",{"type":16,"tag":475,"props":476,"children":478},"pre",{"code":477},"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/Crambin/benchmark.tpr -o Crambin_benchmark.tpr\n",[479],{"type":16,"tag":68,"props":480,"children":481},{"__ignoreMap":7},[482],{"type":22,"value":477},{"type":16,"tag":98,"props":484,"children":485},{},[486],{"type":16,"tag":79,"props":487,"children":488},{},[489],{"type":16,"tag":340,"props":490,"children":491},{},[492],{"type":22,"value":493},"1.4M atom system",{"type":16,"tag":475,"props":495,"children":497},{"code":496},"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerPair/benchmark.tpr -o hEGFRDimerPair_benchmark.tpr\n",[498],{"type":16,"tag":68,"props":499,"children":500},{"__ignoreMap":7},[501],{"type":22,"value":496},{"type":16,"tag":98,"props":503,"children":504},{},[505],{"type":16,"tag":79,"props":506,"children":507},{},[508],{"type":16,"tag":340,"props":509,"children":510},{},[511],{"type":22,"value":512},"3M atom system",{"type":16,"tag":475,"props":514,"children":516},{"code":515},"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerSmallerPL/benchmark.tpr -o hEGFRDimerSmallerPL_benchmark.tpr\n",[517],{"type":16,"tag":68,"props":518,"children":519},{"__ignoreMap":7},[520],{"type":22,"value":515},{"type":16,"tag":37,"props":522,"children":524},{"id":523},"pytorch",[525],{"type":22,"value":136},{"type":16,"tag":149,"props":527,"children":528},{},[529],{"type":16,"tag":24,"props":530,"children":531},{},[532,534,540],{"type":22,"value":533},"The ResNet model is based on the Deep Residual Learning for Image Recognition from this paper ",{"type":16,"tag":30,"props":535,"children":538},{"href":536,"rel":537},"https://arxiv.org/abs/1512.03385",[161],[539],{"type":22,"value":536},{"type":16,"tag":30,"props":541,"children":544},{"href":542,"rel":543},"https://pytorch.org/hub/pytorch_vision_resnet/",[161],[545],{"type":22,"value":542},{"type":16,"tag":24,"props":547,"children":548},{},[549],{"type":16,"tag":340,"props":550,"children":551},{},[552],{"type":22,"value":553},"torchvision should be installed in your environment first",{"type":16,"tag":24,"props":555,"children":556},{},[557],{"type":22,"value":558},"Example how to install 2023",{"type":16,"tag":475,"props":560,"children":562},{"code":561},"module load 2023\nmodule load PyTorch/2.1.2-foss-2023a-CUDA-12.1.1\nmodule load torchvision/0.16.0-foss-2023a-CUDA-12.1.1\n",[563],{"type":16,"tag":68,"props":564,"children":565},{"__ignoreMap":7},[566],{"type":22,"value":561},{"type":16,"tag":24,"props":568,"children":569},{},[570,571],{"type":22,"value":266},{"type":16,"tag":30,"props":572,"children":574},{"href":573,"target":270},"/modules/hpc-handson/scripts/PyTorch_job.sh",[575],{"type":22,"value":576},"PyTorch_job.sh",{"title":7,"searchDepth":578,"depth":578,"links":579},2,[580,582,583,584,585,588],{"id":39,"depth":581,"text":42},3,{"id":45,"depth":581,"text":48},{"id":51,"depth":581,"text":54},{"id":58,"depth":578,"text":61},{"id":139,"depth":578,"text":87,"children":586},[587],{"id":144,"depth":581,"text":147},{"id":276,"depth":578,"text":96,"children":589},[590,591,592,593],{"id":281,"depth":581,"text":109},{"id":371,"depth":581,"text":118},{"id":401,"depth":581,"text":127},{"id":523,"depth":581,"text":136},"markdown","local_fs:modules:hpc-handson:exercises.md","local_fs","modules/hpc-handson/exercises.md","md","---\ntitle: Exercises\ntype: exercise\norder: 6\n---\n\n# Exercises\nChoose an application from the list [below](#applications)\n### 1. Monitor an application with EAR\n### 2. Identify whether the applicaiton is CPU intensive or Memory/Communication intensive\n### 3. Play with PyTorch Automatic Mixed Precision, and maybe model \"size\". What impacts on Energy does this have?\n\n\n## Applications\n\nAll of the Applications used in this tutorial can be found in the project space `/projects/0/energy-course/`\n\n1. [Synthetic Applications](#synthetic-applications)\n2. [Scientific Applications](#scientific-applications)\n   - [HemePure](#hemepure)\n   - [Palabos](#palabos)\n   - [GROMACS](#gromacs)\n   - [PyTorch](#pytorch)\n\n\n## Synthetic Applications\n### NAS Parallel Benchmarks (NPB3.4-MZ MPI+OpenMP) - SP-MZ Benchmark\n> The NAS Parallel Benchmarks (NPB) are a small set of programs designed to help evaluate the performance of parallel supercomputers. The benchmarks are derived from computational fluid dynamics (CFD) applications https://www.nas.nasa.gov/software/npb.html\n\n\nIn this course we will use the \"Multi-zone versions of NPB\" (NPB-MZ). These are designed to exploit multiple levels of parallelism in applications and to test the effectiveness of multi-level and hybrid parallelization (MPI-OpenMP) paradigms and tools. Specifically we use the SP-MZ (even-size zones within a problem class, increased number of zones as problem class grows).\n\n##### Problem Sizes:\n\n| Class     | Mesh size (x)  | Mesh size (y)  | Mesh size (z)  |\n| ----------- | ----------- | ----------- | ----------- |\n| C | 240 | 320 | 28 |\n| D | 1632  | 1216 | 34 |\n\nExample jobscript\n[NPB_job.sh](scripts/NPB_job.sh)\n\n\n\n## Scientific Applications\n### HemePure\n> HemePure/HemeLB developed by the team of Prof Peter Coveney at University College London (UCL), is a software pipeline that simulates blood flow. HemePure is specifically designed to efficiently handle sparse topologies, supports real-time visualization and remote steering of the simulation and can handle fully resolved realistic vessels like those found in the human brain. https://github.com/UCL-CCS/HemePure        \nhttps://github.com/UCL-CCS/HemePure-GPU\n\n* The executables are located in the directory `/projects/0/energy-course/HemePure`. There you will find the `hemepure` and `hemepure_gpu` (CUDA enabled) exectubles.\n**How to run a case**\nWe will be running through an example of pressure driven flow through a bifurcation available in the HemeLB download.\n\nCPU example jobscript\n[hemepure_cpu_job.sh](scripts/HemePure_CPU_job.sh)\n\nGPU example jobscript\n[hemepure_gpu_job.sh](scripts/HemePure_GPU_job.sh)\n\n### Palabos\n\n> The Palabos (Parallel Lattice Boltzmann Solver) library is a framework for general-purpose computational fluid dynamics (CFD), with a kernel based on the lattice Boltzmann method. The case we use in this course is a simulation of blood flow in a inside the 3D aneurysm geometry. https://palabos.unige.ch/\n\nexample jobscript\n[palabos_job.sh](scripts/Palabos_job.sh)\n\n\n### GROMACS\n> **GROMACS** A free and open-source software suite for high-performance molecular dynamics and output analysis.\n\n> **The HECBioSim Benchmarks:** (https://www.hecbiosim.ac.uk/access-hpc/benchmarks)\n\n> **HECBioSim benchmark suite** consists of a set of simple benchmarks for a number of popular Molecular Dynamics (MD) engines, each of which is set at a different atom count. The benchmark suite currently contains benchmarks for the AMBER, GROMACS, LAMMPS and NAMD molecular dynamics packages.\n\nIn this example we will choose the \"465K atom system - hEGFR Dimer of 1IVO and 1NQL\" simulation (which can be found here \u003Chttps://github.com/victorusu/GROMACS_Benchmark_Suite/tree/1.0.0/HECBioSim/hEGFRDimer>). This simulation contains a total number of atoms = 465,399 (Protein atoms = 21,749  Lipid atoms = 134,268  Water atoms = 309,087  Ions = 295). The run will take about 10 minutes to execute (using all 128 cores of an AMD ROME node). The image below shows the simulation that we will run.\n\n- **20K atom system** \n```\ncurl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/Crambin/benchmark.tpr -o Crambin_benchmark.tpr\n```\n- **1.4M atom system** \n``` \ncurl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerPair/benchmark.tpr -o hEGFRDimerPair_benchmark.tpr\n``` \n- **3M atom system** \n```\ncurl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerSmallerPL/benchmark.tpr -o hEGFRDimerSmallerPL_benchmark.tpr\n```\n\n\n\n\n\n### PyTorch\n> The ResNet model is based on the Deep Residual Learning for Image Recognition from this paper https://arxiv.org/abs/1512.03385 \nhttps://pytorch.org/hub/pytorch_vision_resnet/\n\n**torchvision should be installed in your environment first**\n\nExample how to install 2023\n```\nmodule load 2023\nmodule load PyTorch/2.1.2-foss-2023a-CUDA-12.1.1\nmodule load torchvision/0.16.0-foss-2023a-CUDA-12.1.1\n```\n\nExample jobscript\n[PyTorch_job.sh](scripts/PyTorch_job.sh)\n\n",[601,662],{"_path":602,"_dir":603,"_draft":6,"_partial":6,"_locale":7,"title":604,"description":7,"body":605,"_type":594,"_id":659,"_source":596,"_file":660,"_extension":598,"plainText":661},"/main/about","main","About",{"type":13,"children":606,"toc":655},[607,613,618,623,644,650],{"type":16,"tag":56,"props":608,"children":610},{"id":609},"about-the-green-digital-skills-course",[611],{"type":22,"value":612},"About the Green Digital Skills course",{"type":16,"tag":24,"props":614,"children":615},{},[616],{"type":22,"value":617},"In this course, we want to equip the attendees with\na basic knowledge of the link from digital and computational science to energy consumption, and\neventually equivalent CO2 emissions.",{"type":16,"tag":24,"props":619,"children":620},{},[621],{"type":22,"value":622},"The course material consists of two parts:",{"type":16,"tag":98,"props":624,"children":625},{},[626,639],{"type":16,"tag":79,"props":627,"children":628},{},[629,631,637],{"type":22,"value":630},"a lecture, in three chapters, introducing the general topic of ",{"type":16,"tag":68,"props":632,"children":634},{"className":633},[],[635],{"type":22,"value":636},"green",{"type":22,"value":638}," computing",{"type":16,"tag":79,"props":640,"children":641},{},[642],{"type":22,"value":643},"a set of hands-on exercises, covering general good practices for software development, and tools for measuring energy and CO2 emissions on your laptop or on HPC clusters",{"type":16,"tag":56,"props":645,"children":647},{"id":646},"target-audience",[648],{"type":22,"value":649},"Target audience",{"type":16,"tag":24,"props":651,"children":652},{},[653],{"type":22,"value":654},"The target audience for this course includes, but is not limited to, students, reseachers,\ndata scientists, and IT support staff performing computational science, handling data, or\nusing/developing scientific software.",{"title":7,"searchDepth":578,"depth":578,"links":656},[657,658],{"id":609,"depth":578,"text":612},{"id":646,"depth":578,"text":649},"local_fs:main:about.md","main/about.md","---\ntitle: About\n---\n\n## About the Green Digital Skills course\n\nIn this course, we want to equip the attendees with\na basic knowledge of the link from digital and computational science to energy consumption, and\neventually equivalent CO2 emissions.\n\nThe course material consists of two parts: \n - a lecture, in three chapters, introducing the general topic of `green` computing\n - a set of hands-on exercises, covering general good practices for software development, and tools for measuring energy and CO2 emissions on your laptop or on HPC clusters \n\n\n## Target audience\n\nThe target audience for this course includes, but is not limited to, students, reseachers,\ndata scientists, and IT support staff performing computational science, handling data, or\nusing/developing scientific software.\n",{"_path":663,"_dir":603,"_draft":6,"_partial":6,"_locale":7,"title":664,"description":7,"body":665,"_type":594,"_id":681,"_source":596,"_file":682,"_extension":598,"plainText":683},"/main/contribute","Contribute",{"type":13,"children":666,"toc":678},[667,673],{"type":16,"tag":56,"props":668,"children":670},{"id":669},"contributing-to-this-lesson",[671],{"type":22,"value":672},"Contributing to this lesson",{"type":16,"tag":24,"props":674,"children":675},{},[676],{"type":22,"value":677},"Add contributing guidelines for you project.",{"title":7,"searchDepth":578,"depth":578,"links":679},[680],{"id":669,"depth":578,"text":672},"local_fs:main:contribute.md","main/contribute.md","---\ntitle: Contribute\n---\n\n## Contributing to this lesson\n\nAdd contributing guidelines for you project.",1731951827671]