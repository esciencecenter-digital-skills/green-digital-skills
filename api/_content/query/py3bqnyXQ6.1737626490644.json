[{"_path":"/modules/optimizing-energy-use/slides_optimizing_energy_use","_dir":"optimizing-energy-use","_draft":false,"_partial":false,"_locale":"","title":"Optimizing in Practice","description":"===","type":"slides","order":1,"_type":"markdown","_id":"local_fs:modules:optimizing-energy-use:slides_optimizing_energy_use.md","_source":"local_fs","_file":"modules/optimizing-energy-use/slides_optimizing_energy_use.md","_stem":"modules/optimizing-energy-use/slides_optimizing_energy_use","_extension":"md","plainText":"---\ntitle: Optimizing in Practice\ntype: slides\norder: 1\n---\n\n<!-- .slide: data-state=\"title\" -->\n\n# Optimizing Energy Use in Practice\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### What we will cover here\n- What development choices matter?\n- What should you optimize and how do you know?\n- What can you do if you can't change the code you're using?\n\n===\n\n<!-- .slide: data-state=\"standard\" data-background-gradient=\"radial-gradient(rgb(230, 200, 255), rgb(255, 255, 255))\" -->\n\n### _What development choices matter?_\n\n===\n\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Good software practices\n\n<center>\n<img src=\"media/testing-motivation1.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation2.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation3.png\" width=\"30%\" style=\"display:inline;\">\n</center>\n\n<small> Find the complete articles [here](https://www.science.org/doi/full/10.1126/science.314.5807.1856), [here](https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/), and [here](https://www.wired.com/2010/11/1110mars-climate-observer-report/) </small>\n\n\nClean and maintainable software with a robust testing framework is essential\nfor sustainable/green software:\n - Ease of use, reduce error during data settings\n - Less bugs, avoid wasteful bugged runs\n\nNote:\n\nPoor testing and bad software practices lead not only to wrong and retracted papers, but also contribute to a lot of wasted energy...\n\nIn the long run, this is as important as measuring the energy use of your code, optimizing run time etc.\n\nWe (optionally) cover good software practices in this afternoon's hands-on workshop.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Software life cycle\n\n<center>\n<img src=\"media/cicd_scheme.png\" width=\"50%\">\n</center>\n\n- Thinking about long term sustainability, documentation.\n- Reusable software is a key component of modern\nsoftware development, reducing the time/energy consuming\ntask of developing every component of complex softwares.\n\nNote:\n\nWe (optionally) cover good software practices in this afternoon's hands-on workshop.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### What language should I use?\n\n<div style=\"width: 50%; float: left; margin-top: 1%\">\n\n\n</div>\n\n<div style=\"width: 50%; float: right\">\n\n![Ranking of languages](media/language_ranking.png)\n\n</div>\n\nNote:\n\nEnergy ranking of languages across many different benchmarks\n\nTable is from Pereira, R. et al. (2021) <doi:10.1016/j.scico.2021.102609>\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### What language should I use?\n\n<div style=\"width: 50%; float: left; margin-top: 10%; text-align: left;\">\n\n- Let's use C for everything!\n\n</div>\n\n<div style=\"width: 50%; float: right\">\n\n![Ranking of languages](media/language_ranking.png)\n\n</div>\n\nNote:\n\nEnergy ranking of languages across many different benchmarks\n\nTable is from Pereira, R. et al. (2021) <doi:10.1016/j.scico.2021.102609>\n\n===\n\n\n<!-- .slide: data-state=\"standard\" -->\n\n### What language should I use?\n\n<div style=\"width: 50%; float: left; margin-top: 10%; text-align: left;\">\n\n- Let's use C for everything!\n- Please don't. Reality is more nuanced.\n- **Many major numerical libraries in Python are not Python \"under the surface\"**\n  - The core is usually C++ or similar\n  - e.g. PyTorch, Tensorflow, numpy (and many others)\n\n\n</div>\n\n<div style=\"width: 50%; float: right\">\n\n![Ranking of languages](media/language_ranking.png)\n\n</div>\n\n\nNote:\n\nTypical ranking:\n  - C++ and Rust at the top\n  - Python and R at the bottom\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Use the right tool for each task\n\n- Should I avoid \"slow\" and inefficient programming languages?\n- Well, each has its purpose\n  - Python: great for stitching pieces together, easy prototyping\n  - C/C++/Fortran: better at crunching numbers fast\n- Language benchmarks available in the literature can be misleading here\n  - Python/R for can be fine, it's more about the libraries you are using\n\nNote:\n\n===\n\n<!-- .slide: data-state=\"standard\" data-background-gradient=\"radial-gradient(rgb(230, 200, 255), rgb(255, 255, 255))\" -->\n\n### _What should you optimize and how do you know?_\n\n===\n\n\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Don't optimize everything\n\n- **It is important that frequently used tools are as efficient as possible**\n- Your single-use analysis scripts probably don't matter so much - just use the easiest language for the job\n- Optimization is not free and costs development time (and energy) especially in lower level languages like C\n- Generally there are not enough RSEs to do all the coding and optimizations, and researchers don't have time\n\nNote:\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Minimize time to solution\n\n`$$ E = Pt$$`\n- Energy is Power * time\n- As a first approximation, more efficient (faster) software will be energy efficient\n  - It is possible to run on many CPUs although there is overhead from the parallelism.\n\nHow to do this is very problem-dependent!\n\nNote:\nGenerally speaking, finish as quickly as possible so the CPU can drop to a lower energy state\n\nHow to get maximum speed out of your code (including parallelism/accelerators) is beyond the scope of this course by quite some distance.\n\n===\n\n### Profile your code\n\n![](media/code-carbon.png)\n\n- We recommend trying `CodeCarbon` python package\n  - Estimates the amount of carbon dioxide (CO$_2$) produced by the cloud or personal computing resources used to execute the code\n  - Gives recommendations for reducing emissions (e.g. through optimizing the code or by hosting cloud infrastructure in geographical regions that use renewable energy sources)\n  - *More in this afternoon's hands-on workshop*\n\nNote:\n\nThere are many ways to do energy profiling e.g. PMT (Power Measurement Toolkit), Rjoules, and many more.\n\nWe recommend trying CodeCarbon\n\nThe code-carbon.io website decribes it as \"a lightweight software package that seamlessly integrates into your Python codebase. It estimates the amount of carbon dioxide (CO$_2$) produced by the cloud or personal computing resources used to execute the code.\n\nIt then shows developers how they can lessen emissions by optimizing their code or by hosting their cloud infrastructure in geographical regions that use renewable energy sources.\"\n\nThis sounds like a good place to start for researchers here.\n\n===\n\n\n<img src=\"media/codecarbon_dashboard_screenshot.png\" width=\"100%\" />\n\nNote:\n\nScreenshot from the website to illustrate functionality: <https://codecarbon.io/#howitwork>\n\nIn principle there is a dashboard showing your usage in the context of everyday values,\nas well as suggestions for where to run your cloud workflows to reduce carbon cost (assuming\nyou have control over this).\n\nHowever, getting the dashboard locally is not really possible/easy yet unfortunately.\nCodeCarbon is promising and developing fast, with lots of interested parties, so\na good choice for the future.\n\n===\n\n\n<!-- .slide: data-state=\"standard\" data-background-gradient=\"radial-gradient(rgb(230, 200, 255), rgb(255, 255, 255))\" -->\n\n### _What can you do if you can't change the code you're using?_\n\n===\n\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Change how you run it\n\n\n- Perhaps you can profile the code but you cannot do much with the results\n  - e.g. You are not the developer, or don't feel experienced enough\n\n<img src=\"media/ear-logo.png\" width=\"40%\" style=\"padding-top: 1cm;\"/>\n\n- Tools like the Energy Aware Runtime can help\n  - Dynamically scales the CPU or GPU clock frequency up or down while the code is running\n  - When code is waiting a lot (for I/O or memory), frequency is scaled down\n  - Remember that Energy ~ frequency$^2$\n  - *Also covered in this afternoon's hands-on workshop (HPC-track)*\n\nNote:\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Change when you run it\n\n<img src=\"media/carbon-aware-software.png\" width=\"60%\">\n\n- Interesting new tools such as Carbon Aware Task Scheduler (UK-only currently)\n  - Tells you what is the best time to run in the next 48 hours\n- Think about what resources you request\n  - Number of CPU cores is clearly a large contributor\n  - Carbon footprint of memory is interesting - doesn't matter how much you use, but how much is available. Don't request 10 times the memory you need on a server \"just in case\"\n\nNote:\n\nCarbon awareness image is from <https://github.com/Green-Software-Foundation/carbon-aware-sdk>.\n\nMost jobs have some flexibility - we don't care if we run it right now or in a few hours. Especially over the weekend.\n\n\n===\n\n\n<!-- .slide: data-state=\"standard\" -->\n\n### A warning: Jevon's Paradox\n\n\n_In economics, the Jevons paradox occurs when technological progress increases\nthe efficiency with which a resource is used (reducing the amount necessary for any one use),\nbut the falling cost of use induces increases in demand enough that resource use is increased,\nrather than reduced._\n\n- [https://en.wikipedia.org/wiki/Jevons_paradox](https://en.wikipedia.org/wiki/Jevons_paradox)\n\n![Interchange in Chicago](media/interchange.jpg)\n\nNote:\nIn practice, reducing energy use overall is more about organizational policy and value judgements about what the expected return is for a given amount of energy used.\n\n* Are you thinking about this the right way?\n* Is green computing really a purely technical issue?\n* Is your footprint by computing really your biggest contribution to the climate crisis?\n* Organizational policy is as important if not more important\n\nImage attribution:\nSea Cow, CC BY-SA 4.0 <https://creativecommons.org/licenses/by-sa/4.0>, via Wikimedia Commons\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Key points\n  \n- Don't neglect good software development practices\n- The libraries you use can matter as much as language choice\n- Only optimize code if it will have impact (runs a lot, uses a lot of energy)\n- If you can't change the code, choose when/where to submit it or use a frequency scaling tool\n\n===\n\n\n<!-- .slide: data-state=\"keepintouch\" -->\n\n\nwww.esciencecenter.nl\n\ninfo@esciencecenter.nl\n\n020 - 460 47 70\n"},{"_path":"/modules/software-development-handson/excercises-code-carbon-r","_dir":"software-development-handson","_draft":false,"_partial":false,"_locale":"","title":"Code Carbon in R","description":"","type":"exercise","order":6,"_type":"markdown","_id":"local_fs:modules:software-development-handson:excercises-code-carbon-r.md","_source":"local_fs","_file":"modules/software-development-handson/excercises-code-carbon-r.md","_stem":"modules/software-development-handson/excercises-code-carbon-r","_extension":"md","plainText":"---\ntitle: \"Code Carbon in R\"\ntype: exercise\norder: 6\n---\n\n# CodeCarbon in R\n\n## Introduction\n---------------\n\nIf you are mainly coding in R, you may want to learn more about the impact of your R code in terms of energy consumption and carbon footprint. However, there aren't yet as of now R packages that allow to do this in a reliable and user-friendly way. One promising tool is the [**RJoules package**](https://rishalab.github.io/RJoules/); however, it is still in development and restricted to certain operating systems used by developers (i.e., linux).\n\n**CodeCarbon** is a Python package that estimates the carbon footprint of code. You can [read more about it here](https://mlco2.github.io/codecarbon/). This Python module is well documented and easy to use. How sad that it is only available for Python... But there is a way to use it in R! In fact, it is possible and relatively easy to run Python in RStudio. This can be done through the [`reticulate`](https://rstudio.github.io/reticulate/) package, which allows you to run Python code from R directly into your R script. For more complex workflows, [**Quarto**](https://quarto.org/docs/computations/python.html) can be used to combine R and Python code in the same document. In fact, Quarto markdown files (.qmd) are exceptionally good at calling R and Python code in the same document, whilst also making it explicit what code belongs to each, using the native syntax for both languages in the same document and analysis workflow.\n\nThis tutorial shows how to implement CodeCarbon in R through RStudio. An example workflow is provided by measuring the carbon footprint of two different R packages used to fit mixed-effects models. Additionally, time-varying confounding is introduced into the built-in R `ChickWeight` data through simulation to compare how different statistical modelling strategies to account for confounding compare in terms of their energy consumption and carbon footprint.\n\n## Installation\n---------------\n\nThe detailed instructions for installation of Python and CodeCarbon are found in the [prior lesson](https://esciencecenter-digital-skills.github.io/green-digital-skills/modules/software-development-handson/exercises_codecarbon). It is assumed that you have already followed these steps.\n\nIf you have not done so, [install R and RStudio](https://posit.co/download/rstudio-desktop/). Note that these demonstrations were conducted under R version 4.4.0 and RStudio 2024.04.0, so it is recommended that you install these or more recent versions.\n\nLastly, all the necessary materials and R scripts for this tutorial can be downloaded from Zenodo (doi: [10.5281/zenodo.14617645](https://doi.org/10.5281/zenodo.14617645)). You can also download the ZIP file by [following this link](https://zenodo.org/records/14617645/files/UtrechtUniversity/code-carbon-r-v1.0.0.zip?download=1), unpack it, and place it in a familiar folder in your computer. \n\n## Calling CodeCarbon in an R script\n-------------------------------------\n\nYou will found a sample R script named **code-carbon-script.R** inside the *R folder* if you successfully downloaded the material with the prior steps. This script can be adapted to test your own R code. It incorporates the following steps:\n\nFirst, you will need to install the `reticulate` package and load it into your session:\n\n```         \ninstall.packages(\"reticulate\")\nlibrary(reticulate)\n```\n\nLoad the CodeCarbon module using the reticulate [`import`](https://rstudio.github.io/reticulate/reference/import.html) function.\n\n```         \ncodecarbon <- import(\"codecarbon\")\n```\n\nImport the OfflineEmissionsTracker class\n\n```         \nOfflineEmissionsTracker <- codecarbon$OfflineEmissionsTracker\n```\n\nSet the emissions trackers parameter and initialize. This will automatically detect your system's characteristics and open a file to save the report later on. You can also specify the country code, timing of measurements, among others. See the [CodeCarbon documentation](https://mlco2.github.io/codecarbon/parameters.html#id6) for more details:\n\n```         \ntracker <- OfflineEmissionsTracker(\n  country_iso_code = \"NLD\",\n  measure_power_secs = 5\n)\n```\n\nStart tracking the emissions, run your code, and finish tracking once your code ran.\n\n```         \ntracker$start()\n\n# Your R code here\n\ntracker$stop()\n```\n\nThis will terminate the report and save it in your default working directory, unless you specified earlier the path to save it according to the provided documentation.\n\nNote that CodeCarbon will continue to track until you explicitly stop it with `tracker$stop()`. Thus, you may want to run all lines of code from start -\\> code -\\> stop in one go to measure the consumption of that specific code.\n\n## Calling CodeCarbon in a Quarto markdown (qmd) file in RStudio\n----------------------------------------------------------------\n\nIf you use Quarto, you can call Python and R code in the same document, using their native syntax. For this, you can specify the language of the code block using the `python` or `r` tags:\n\n\n```\n{python}\n# Your python code here\n``` \n\n```\n{r}\n# Your R code here\n```\n\nThe advantage of using Quarto is that you don't need to rewrite python code using the `reticulate` syntax. You can simply copy and paste the Python code into the `python` code block. This is a great advantage when you are not very familiar with Python and you want to reuse well-documented native python code, or simply to efficiently communicate with Python programmers.\n\nBecause Rstudio loads the reticulate package once it reads the `python` tag, you don't need to load the `reticulate` package in the code block. Thus, we will start by calling the CodeCarbon module in Python.\n\n### Setup \n\nIn the downloaded folder, you will find an R project icon named **code-carbon-R.Rproj**. Open this project in RStudio. This will set a default working directory, which is useful to read the associated scripts and save the emissions reports. Now, navigate to the **R** folder, where you will find a document called **code-carbon-Quarto.qmd**. You may open this file in RStudio to reproduce the following steps in the corresponding section. \n\n> *Tip: The rest of this tutorial can be followed through the code-carbon-Quarto.qmd file in RStudio.*\n\n### Instructions  \n\nStart by pressing the play button below that reads \"Run Current Chunk\":\n\n```\n{python}\n# Load the CodeCarbon module\nfrom codecarbon import OfflineEmissionsTracker\n```\n\nThen, we will initialize the tracker and start tracking the emissions. Beware that you will need to stop tracking the emissions before with the code that will appear later on in this document to start a new tracker. For this, we can use a safety check to avoid running multiple trackers at the same time.\n\n```\n{python}\ntracker = OfflineEmissionsTracker(country_iso_code=\"NLD\",\n                                 measure_power_secs=5)\n\nif getattr(tracker, \"_start_time\", None) is not None:\n    print(\"Warning: Tracker is already running! Did you forget to stop it?\")\nelse:\n    tracker.start()\n    print(\"Tracker started successfully.\")\n```\n\nYou can now change to R language by using the `r` tag. In this code block, you can introduce your R code. For example, a fictitious computationally intensive function for which you would like to test its energy consumption.\n\n``` \n{r}\nintense_computation(large_dataset)\n```\n\nFinally, you can stop tracking the emissions and print the results. You will again find the report as a csv file in your default working directory.\n\n\n```\n{python}\nemissions: float = tracker.stop()\nprint(f\"Emissions tracked: {emissions} kg CO₂e\")\n```\n\nThis value represents the estimated carbon emissions equivalent in kilograms.\n\nCombining R and Python code in a .qmd file will work best if you are rendering your document to any of the output report files implemented in Quarto (i.e., PDF, html, docx, slides, etc). This is because code blocks are executed in the order they are found in the document. However, if you mainly work with R scripts, running CodeCarbon with the `reticulate` package in R will be the best approach.\n\nFor the last part of this tutorial, a hybrid approach is used where:\n1.  Individual R scripts are adapted from the sample **code-carbon-script.R** to include CodeCarbon tracking for every individual task.  \n2.  The individual R scripts are then sourced into the Quarto document to demonstrate the energy consumption and carbon footprint of different R packages used to fit mixed-effects models.  \n3.  This model workflow produces an individual output report for every R script and task, which will be found in the `emissions` folder. \n\nThis approach offers the advantage of more precise measurements because every script starts with the initialization of the tracker and ends with the stop command in one go.\n\n## Demonstration\n----------------\n\nWe will compare two R packages commonly used to fit mixed-effects models that are often compared due to their computational speed. `lme4` is suitable for generalized linear mixed models, runs in C++, and is optimized for speed,<sup>1</sup> whereas `nlme` can additionally fit non-linear models, but is written in R language (before: S and S-Plus)<sup>2</sup> which makes computations somewhat slower and with a potentially higher carbon footprint.\n\nHowever, there are often preliminary modelling steps needed when trying to elucidate the main effects with these two packages. One example is time varying confounding, for which different modelling approaches have been proposed. Inverse probability weighting (IPW) is a powerful tool for such analyses, but many different models can be used to obtain inverse probability weights to be used in the main mixed-effects models. Generalized linear models can be used as a fast an computationally efficient option to obtain IPW through the built-in `stats` R package, which is written in R and C language, but is highly susceptible to incorrect model specification. Novel non-parametric methods are robust to model misspecification,<sup>3</sup> and are implemented in the `CBPS` package, which despite running in C++ for computational efficiency, uses intensive and lengthy calculations. These two methods will be compared using Python `CodeCarbon`. We will use the `WeightIt` package written in R language,<sup>4</sup> which has implemented these two methods and many others which can similarly be tested and compared in terms of energy consumption and carbon footprint.\n\nWe will use the built-in R `ChickWeight` dataset to simulate new data with time-varying treatment-outcome confounding to study the effect of 4 different diets on weight, by accounting for the confounding effect of a time-varying binary disease 1, and an ordinal disease 2, which disease status may also vary in time.\n\nFirst, install and load all the necessary R packages to avoid these one-time installations being tracked by CodeCarbon. The `pacman` package nicely handles installation and loading.\n\n``` {.r .cell-code}\nif (!require(\"pacman\", quietly = TRUE)) {\n  install.packages(\"pacman\")\n}\n\npacman::p_load(\n  tidyverse,        # Used for basic data handling and visualization.\n  conflicted,       # Used to handle conflicts between packages.\n  reticulate,       # Used to call Python code in R.\n  lme4,             # Used to fit linear mixed-effects models.\n  nlme,             # Used to fit non-linear mixed-effects models.\n  WeightIt,         # Used to obtain inverse probability weights (IPW).\n  CBPS              # Used to obtain non-parametric CBPS IPW.\n)\n\nconflicts_prefer(dplyr::select, dplyr::lag, dplyr::filter)\n```\n\n\nWe now simulate the data and measure the time required to complete and it's carbon footprint. The input and output parameters have been adapted in the R script to save the output file in the `emissions` folder. By running this chunk of code, you will also see the live emissions tracking as R console output.\n\n> Important! If the code is interrupted before finishing, emissions will keep to be tracked and shown until you stop it by running the last line in the scripts. This is important to keep in mind when running new code chunks and start a new tracker. Run tracker\\$stop() whenever your code is prematurely interrupted before reaching the end of the script.\n\nTip: If any of the scripts take too long to run, you can try modifying the `sample_size` parameter in the **data_simulation.R** script. This will also be changed below in this code file to explore emissions with different sample sizes.\n\n``` {.r .cell-code}\nsource(\"data-simulation.R\")\n```\n\nLet's now measure the energy consumption of obtaining inverse probability weights with a generalized linear model (glm) in the built-in `stats` R package.\n\n\n``` {.r .cell-code}\nsource(\"ipw_glm.R\")\n```\n\n\nAnd compare against the novel non-parametric method implemented in the `CBPS` package. This will take longer to run than the prior steps, so we will track emissions every 5 seconds.\n\n``` {.r .cell-code}\nsource(\"ipw_CBPS.R\")\n```\n\n> Question: Would you prefer the faster glm method or the more robust CBPS method to obtain IPW? \n\nFinally, we will fit the mixed-effects models with the `lme4` and `nlme` packages, and compare their energy consumption.\n\n``` {.r .cell-code}\nsource(\"mixed_model_lme4.R\")\n```\n\n``` {.r .cell-code}\nsource(\"mixed_model_nlme.R\")\n```\n\n### Simulation with a larger dataset\n\n\nThe original tests used 550 observations in a total of 50 chicks. This was sufficient to demonstrate the differences in emissions with the two IPW methods, but not with the different mixed-effects packages. We will next simulate a much larger dataset with 5000 chicks to be able to compare `lme4` and `nlme`.\n\n\n``` {.r .cell-code}\n# Simulate new data and prepare the dataset for analysis \n\nsimulated_data <- simulate_chickweight(n_chicks = 5000)\n\nanalysis_data <- simulated_data %>%\n  arrange(Chick, Time) %>%\n  group_by(Chick) %>%\n  mutate(\n    lag_disease_1 = lag(disease_1),\n    lag_disease_2 = lag(disease_2),\n    lag_weight = lag(weight)\n  ) %>%\n  ungroup()\n\nanalysis_data <- analysis_data %>%\n  filter(!is.na(lag_disease_1))\n```\n\n\nWe will use the IPW obtained with glm for faster computations.\n\n\n``` {.r .cell-code}\nsource(\"ipw_glm.R\")\n```\n\nAnd now we can compare the energy consumption of fitting the exact same model with the `lme4` and `nlme`.\n\n\n``` {.r .cell-code}\nsource(\"mixed_model_lme4.R\")\n```\n\n``` {.r .cell-code}\nsource(\"mixed_model_nlme.R\")\n```\n\n> Question: How do the energy consumption and carbon footprint of the two packages compare with the larger dataset when fitting the same model? \n\n## Conclusions\n---------------\n\nThis tutorial provides different alternatives to implement CodeCarbon in R workflows. The provided code can be adapted and used by R code developers and other R users to test the efficiency and carbon footprint of their code. Existing R packages able to perform the same tasks can be compared in terms of energy consumption, which can be an additional criterion to choose between them. However, it should be kept in mind that energy consumption an carbon footprint are among the many factors to consider when choosing between different packages. For instance, it could be justifiable to use a method that consumes more energy and has a higher carbon footprint if it offers other significant advantages. \n\n\n## References \n---------------\n\n1.  Bates, Douglas, Martin Mächler, Ben Bolker, and Steve Walker. 2015. “Fitting Linear Mixed-Effects Models Using Lme4.” Journal of Statistical Software 67 (1). https://doi.org/10.18637/jss.v067.i01.\n\n2.  Fong, Christian, Chad Hazlett, and Kosuke Imai. 2018. “Covariate Balancing Propensity Score for a Continuous Treatment: Application to the Efficacy of Political Advertisements.” The Annals of Applied Statistics 12 (1). https://doi.org/10.1214/17-aoas1101.\n\n3.  Greifer, Noah. 2017. “WeightIt: Weighting for Covariate Balance in Observational Studies.” The R Foundation. https://doi.org/10.32614/cran.package.weightit.\n\n4.  Pinheiro, José C., and Douglas M. Bates. 2000. Mixed-Effects Models in s and s-PLUS. New York: Springer. https://doi.org/10.1007/b98882."}]