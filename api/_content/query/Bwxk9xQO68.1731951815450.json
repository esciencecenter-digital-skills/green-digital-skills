{"_path":"/modules/hpc-handson/exercises","_dir":"hpc-handson","_draft":false,"_partial":false,"_locale":"","title":"Exercises","description":"Choose an application from the list below","type":"exercise","order":6,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"exercises"},"children":[{"type":"text","value":"Exercises"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Choose an application from the list "},{"type":"element","tag":"a","props":{"href":"#applications"},"children":[{"type":"text","value":"below"}]}]},{"type":"element","tag":"h3","props":{"id":"_1-monitor-an-application-with-ear"},"children":[{"type":"text","value":"1. Monitor an application with EAR"}]},{"type":"element","tag":"h3","props":{"id":"_2-identify-whether-the-applicaiton-is-cpu-intensive-or-memorycommunication-intensive"},"children":[{"type":"text","value":"2. Identify whether the applicaiton is CPU intensive or Memory/Communication intensive"}]},{"type":"element","tag":"h3","props":{"id":"_3-play-with-pytorch-automatic-mixed-precision-and-maybe-model-size-what-impacts-on-energy-does-this-have"},"children":[{"type":"text","value":"3. Play with PyTorch Automatic Mixed Precision, and maybe model \"size\". What impacts on Energy does this have?"}]},{"type":"element","tag":"h2","props":{"id":"applications"},"children":[{"type":"text","value":"Applications"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"All of the Applications used in this tutorial can be found in the project space "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/projects/0/energy-course/"}]}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#synthetic-applications"},"children":[{"type":"text","value":"Synthetic Applications"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#scientific-applications"},"children":[{"type":"text","value":"Scientific Applications"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#hemepure"},"children":[{"type":"text","value":"HemePure"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#palabos"},"children":[{"type":"text","value":"Palabos"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#gromacs"},"children":[{"type":"text","value":"GROMACS"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#pytorch"},"children":[{"type":"text","value":"PyTorch"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"synthetic-applications"},"children":[{"type":"text","value":"Synthetic Applications"}]},{"type":"element","tag":"h3","props":{"id":"nas-parallel-benchmarks-npb34-mz-mpiopenmp-sp-mz-benchmark"},"children":[{"type":"text","value":"NAS Parallel Benchmarks (NPB3.4-MZ MPI+OpenMP) - SP-MZ Benchmark"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The NAS Parallel Benchmarks (NPB) are a small set of programs designed to help evaluate the performance of parallel supercomputers. The benchmarks are derived from computational fluid dynamics (CFD) applications "},{"type":"element","tag":"a","props":{"href":"https://www.nas.nasa.gov/software/npb.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.nas.nasa.gov/software/npb.html"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this course we will use the \"Multi-zone versions of NPB\" (NPB-MZ). These are designed to exploit multiple levels of parallelism in applications and to test the effectiveness of multi-level and hybrid parallelization (MPI-OpenMP) paradigms and tools. Specifically we use the SP-MZ (even-size zones within a problem class, increased number of zones as problem class grows)."}]},{"type":"element","tag":"h5","props":{"id":"problem-sizes"},"children":[{"type":"text","value":"Problem Sizes:"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Class"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Mesh size (x)"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Mesh size (y)"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Mesh size (z)"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"C"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"240"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"320"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"28"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"D"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1632"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1216"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"34"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Example jobscript\n"},{"type":"element","tag":"a","props":{"href":"/modules/hpc-handson/scripts/NPB_job.sh","target":"_blank"},"children":[{"type":"text","value":"NPB_job.sh"}]}]},{"type":"element","tag":"h2","props":{"id":"scientific-applications"},"children":[{"type":"text","value":"Scientific Applications"}]},{"type":"element","tag":"h3","props":{"id":"hemepure"},"children":[{"type":"text","value":"HemePure"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HemePure/HemeLB developed by the team of Prof Peter Coveney at University College London (UCL), is a software pipeline that simulates blood flow. HemePure is specifically designed to efficiently handle sparse topologies, supports real-time visualization and remote steering of the simulation and can handle fully resolved realistic vessels like those found in the human brain. "},{"type":"element","tag":"a","props":{"href":"https://github.com/UCL-CCS/HemePure","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/UCL-CCS/HemePure"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://github.com/UCL-CCS/HemePure-GPU","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/UCL-CCS/HemePure-GPU"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The executables are located in the directory "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/projects/0/energy-course/HemePure"}]},{"type":"text","value":". There you will find the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"hemepure"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"hemepure_gpu"}]},{"type":"text","value":" (CUDA enabled) exectubles.\n"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"How to run a case"}]},{"type":"text","value":"\nWe will be running through an example of pressure driven flow through a bifurcation available in the HemeLB download."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CPU example jobscript\n"},{"type":"element","tag":"a","props":{"href":"/modules/hpc-handson/scripts/HemePure_CPU_job.sh","target":"_blank"},"children":[{"type":"text","value":"hemepure_cpu_job.sh"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"GPU example jobscript\n"},{"type":"element","tag":"a","props":{"href":"/modules/hpc-handson/scripts/HemePure_GPU_job.sh","target":"_blank"},"children":[{"type":"text","value":"hemepure_gpu_job.sh"}]}]},{"type":"element","tag":"h3","props":{"id":"palabos"},"children":[{"type":"text","value":"Palabos"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Palabos (Parallel Lattice Boltzmann Solver) library is a framework for general-purpose computational fluid dynamics (CFD), with a kernel based on the lattice Boltzmann method. The case we use in this course is a simulation of blood flow in a inside the 3D aneurysm geometry. "},{"type":"element","tag":"a","props":{"href":"https://palabos.unige.ch/","rel":["nofollow"]},"children":[{"type":"text","value":"https://palabos.unige.ch/"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"example jobscript\n"},{"type":"element","tag":"a","props":{"href":"/modules/hpc-handson/scripts/Palabos_job.sh","target":"_blank"},"children":[{"type":"text","value":"palabos_job.sh"}]}]},{"type":"element","tag":"h3","props":{"id":"gromacs"},"children":[{"type":"text","value":"GROMACS"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"GROMACS"}]},{"type":"text","value":" A free and open-source software suite for high-performance molecular dynamics and output analysis."}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"The HECBioSim Benchmarks:"}]},{"type":"text","value":" ("},{"type":"element","tag":"a","props":{"href":"https://www.hecbiosim.ac.uk/access-hpc/benchmarks","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.hecbiosim.ac.uk/access-hpc/benchmarks"}]},{"type":"text","value":")"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"HECBioSim benchmark suite"}]},{"type":"text","value":" consists of a set of simple benchmarks for a number of popular Molecular Dynamics (MD) engines, each of which is set at a different atom count. The benchmark suite currently contains benchmarks for the AMBER, GROMACS, LAMMPS and NAMD molecular dynamics packages."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this example we will choose the \"465K atom system - hEGFR Dimer of 1IVO and 1NQL\" simulation (which can be found here "},{"type":"element","tag":"a","props":{"href":"https://github.com/victorusu/GROMACS_Benchmark_Suite/tree/1.0.0/HECBioSim/hEGFRDimer","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/victorusu/GROMACS_Benchmark_Suite/tree/1.0.0/HECBioSim/hEGFRDimer"}]},{"type":"text","value":"). This simulation contains a total number of atoms = 465,399 (Protein atoms = 21,749  Lipid atoms = 134,268  Water atoms = 309,087  Ions = 295). The run will take about 10 minutes to execute (using all 128 cores of an AMD ROME node). The image below shows the simulation that we will run."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"20K atom system"}]}]}]},{"type":"element","tag":"pre","props":{"code":"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/Crambin/benchmark.tpr -o Crambin_benchmark.tpr\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/Crambin/benchmark.tpr -o Crambin_benchmark.tpr\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1.4M atom system"}]}]}]},{"type":"element","tag":"pre","props":{"code":"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerPair/benchmark.tpr -o hEGFRDimerPair_benchmark.tpr\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerPair/benchmark.tpr -o hEGFRDimerPair_benchmark.tpr\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"3M atom system"}]}]}]},{"type":"element","tag":"pre","props":{"code":"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerSmallerPL/benchmark.tpr -o hEGFRDimerSmallerPL_benchmark.tpr\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"curl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerSmallerPL/benchmark.tpr -o hEGFRDimerSmallerPL_benchmark.tpr\n"}]}]},{"type":"element","tag":"h3","props":{"id":"pytorch"},"children":[{"type":"text","value":"PyTorch"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The ResNet model is based on the Deep Residual Learning for Image Recognition from this paper "},{"type":"element","tag":"a","props":{"href":"https://arxiv.org/abs/1512.03385","rel":["nofollow"]},"children":[{"type":"text","value":"https://arxiv.org/abs/1512.03385"}]},{"type":"element","tag":"a","props":{"href":"https://pytorch.org/hub/pytorch_vision_resnet/","rel":["nofollow"]},"children":[{"type":"text","value":"https://pytorch.org/hub/pytorch_vision_resnet/"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"torchvision should be installed in your environment first"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Example how to install 2023"}]},{"type":"element","tag":"pre","props":{"code":"module load 2023\nmodule load PyTorch/2.1.2-foss-2023a-CUDA-12.1.1\nmodule load torchvision/0.16.0-foss-2023a-CUDA-12.1.1\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"module load 2023\nmodule load PyTorch/2.1.2-foss-2023a-CUDA-12.1.1\nmodule load torchvision/0.16.0-foss-2023a-CUDA-12.1.1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Example jobscript\n"},{"type":"element","tag":"a","props":{"href":"/modules/hpc-handson/scripts/PyTorch_job.sh","target":"_blank"},"children":[{"type":"text","value":"PyTorch_job.sh"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_1-monitor-an-application-with-ear","depth":3,"text":"1. Monitor an application with EAR"},{"id":"_2-identify-whether-the-applicaiton-is-cpu-intensive-or-memorycommunication-intensive","depth":3,"text":"2. Identify whether the applicaiton is CPU intensive or Memory/Communication intensive"},{"id":"_3-play-with-pytorch-automatic-mixed-precision-and-maybe-model-size-what-impacts-on-energy-does-this-have","depth":3,"text":"3. Play with PyTorch Automatic Mixed Precision, and maybe model \"size\". What impacts on Energy does this have?"},{"id":"applications","depth":2,"text":"Applications"},{"id":"synthetic-applications","depth":2,"text":"Synthetic Applications","children":[{"id":"nas-parallel-benchmarks-npb34-mz-mpiopenmp-sp-mz-benchmark","depth":3,"text":"NAS Parallel Benchmarks (NPB3.4-MZ MPI+OpenMP) - SP-MZ Benchmark"}]},{"id":"scientific-applications","depth":2,"text":"Scientific Applications","children":[{"id":"hemepure","depth":3,"text":"HemePure"},{"id":"palabos","depth":3,"text":"Palabos"},{"id":"gromacs","depth":3,"text":"GROMACS"},{"id":"pytorch","depth":3,"text":"PyTorch"}]}]}},"_type":"markdown","_id":"local_fs:modules:hpc-handson:exercises.md","_source":"local_fs","_file":"modules/hpc-handson/exercises.md","_extension":"md","plainText":"---\ntitle: Exercises\ntype: exercise\norder: 6\n---\n\n# Exercises\nChoose an application from the list [below](#applications)\n### 1. Monitor an application with EAR\n### 2. Identify whether the applicaiton is CPU intensive or Memory/Communication intensive\n### 3. Play with PyTorch Automatic Mixed Precision, and maybe model \"size\". What impacts on Energy does this have?\n\n\n## Applications\n\nAll of the Applications used in this tutorial can be found in the project space `/projects/0/energy-course/`\n\n1. [Synthetic Applications](#synthetic-applications)\n2. [Scientific Applications](#scientific-applications)\n   - [HemePure](#hemepure)\n   - [Palabos](#palabos)\n   - [GROMACS](#gromacs)\n   - [PyTorch](#pytorch)\n\n\n## Synthetic Applications\n### NAS Parallel Benchmarks (NPB3.4-MZ MPI+OpenMP) - SP-MZ Benchmark\n> The NAS Parallel Benchmarks (NPB) are a small set of programs designed to help evaluate the performance of parallel supercomputers. The benchmarks are derived from computational fluid dynamics (CFD) applications https://www.nas.nasa.gov/software/npb.html\n\n\nIn this course we will use the \"Multi-zone versions of NPB\" (NPB-MZ). These are designed to exploit multiple levels of parallelism in applications and to test the effectiveness of multi-level and hybrid parallelization (MPI-OpenMP) paradigms and tools. Specifically we use the SP-MZ (even-size zones within a problem class, increased number of zones as problem class grows).\n\n##### Problem Sizes:\n\n| Class     | Mesh size (x)  | Mesh size (y)  | Mesh size (z)  |\n| ----------- | ----------- | ----------- | ----------- |\n| C | 240 | 320 | 28 |\n| D | 1632  | 1216 | 34 |\n\nExample jobscript\n[NPB_job.sh](scripts/NPB_job.sh)\n\n\n\n## Scientific Applications\n### HemePure\n> HemePure/HemeLB developed by the team of Prof Peter Coveney at University College London (UCL), is a software pipeline that simulates blood flow. HemePure is specifically designed to efficiently handle sparse topologies, supports real-time visualization and remote steering of the simulation and can handle fully resolved realistic vessels like those found in the human brain. https://github.com/UCL-CCS/HemePure        \nhttps://github.com/UCL-CCS/HemePure-GPU\n\n* The executables are located in the directory `/projects/0/energy-course/HemePure`. There you will find the `hemepure` and `hemepure_gpu` (CUDA enabled) exectubles.\n**How to run a case**\nWe will be running through an example of pressure driven flow through a bifurcation available in the HemeLB download.\n\nCPU example jobscript\n[hemepure_cpu_job.sh](scripts/HemePure_CPU_job.sh)\n\nGPU example jobscript\n[hemepure_gpu_job.sh](scripts/HemePure_GPU_job.sh)\n\n### Palabos\n\n> The Palabos (Parallel Lattice Boltzmann Solver) library is a framework for general-purpose computational fluid dynamics (CFD), with a kernel based on the lattice Boltzmann method. The case we use in this course is a simulation of blood flow in a inside the 3D aneurysm geometry. https://palabos.unige.ch/\n\nexample jobscript\n[palabos_job.sh](scripts/Palabos_job.sh)\n\n\n### GROMACS\n> **GROMACS** A free and open-source software suite for high-performance molecular dynamics and output analysis.\n\n> **The HECBioSim Benchmarks:** (https://www.hecbiosim.ac.uk/access-hpc/benchmarks)\n\n> **HECBioSim benchmark suite** consists of a set of simple benchmarks for a number of popular Molecular Dynamics (MD) engines, each of which is set at a different atom count. The benchmark suite currently contains benchmarks for the AMBER, GROMACS, LAMMPS and NAMD molecular dynamics packages.\n\nIn this example we will choose the \"465K atom system - hEGFR Dimer of 1IVO and 1NQL\" simulation (which can be found here <https://github.com/victorusu/GROMACS_Benchmark_Suite/tree/1.0.0/HECBioSim/hEGFRDimer>). This simulation contains a total number of atoms = 465,399 (Protein atoms = 21,749  Lipid atoms = 134,268  Water atoms = 309,087  Ions = 295). The run will take about 10 minutes to execute (using all 128 cores of an AMD ROME node). The image below shows the simulation that we will run.\n\n- **20K atom system** \n```\ncurl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/Crambin/benchmark.tpr -o Crambin_benchmark.tpr\n```\n- **1.4M atom system** \n``` \ncurl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerPair/benchmark.tpr -o hEGFRDimerPair_benchmark.tpr\n``` \n- **3M atom system** \n```\ncurl -LJ https://github.com/victorusu/GROMACS_Benchmark_Suite/raw/1.0.0/HECBioSim/hEGFRDimerSmallerPL/benchmark.tpr -o hEGFRDimerSmallerPL_benchmark.tpr\n```\n\n\n\n\n\n### PyTorch\n> The ResNet model is based on the Deep Residual Learning for Image Recognition from this paper https://arxiv.org/abs/1512.03385 \nhttps://pytorch.org/hub/pytorch_vision_resnet/\n\n**torchvision should be installed in your environment first**\n\nExample how to install 2023\n```\nmodule load 2023\nmodule load PyTorch/2.1.2-foss-2023a-CUDA-12.1.1\nmodule load torchvision/0.16.0-foss-2023a-CUDA-12.1.1\n```\n\nExample jobscript\n[PyTorch_job.sh](scripts/PyTorch_job.sh)\n\n"}