{"_path":"/modules/software-development-handson/exercises_cicd","_dir":"software-development-handson","_draft":false,"_partial":false,"_locale":"","title":"CI/CD optimization","description":"","type":"exercise","order":4,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"make-your-automated-testing-framework-use-less-energy"},"children":[{"type":"text","value":"Make your automated testing framework use less energy"}]},{"type":"element","tag":"h2","props":{"id":"testing-is-necessary"},"children":[{"type":"text","value":"Testing is necessary"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A robust testing framework is an essential part of good software development practices. It is even more vital in a research environment since wrong or misleading scientific results may be caused by bad or insufficient testing. Automated testing aids in scientific reproducibility and reduces the amount of time wasted trying to go back to find which version still worked with a given feature."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If you are unsure about what a testing framework is or how to set one up, you can learn about it in the "},{"type":"element","tag":"a","props":{"href":"exercises_good-practices"},"children":[{"type":"text","value":"Good Practices"}]},{"type":"text","value":" exercises of this hands-on module (specifically, it is "},{"type":"element","tag":"a","props":{"href":"exercises_good-practices#_4-testing"},"children":[{"type":"text","value":"step 4"}]},{"type":"text","value":". Adding tests to your scientific code is a good step towards avoiding wasted energy in the long run."}]},{"type":"element","tag":"h2","props":{"id":"testing-uses-energy"},"children":[{"type":"text","value":"Testing uses energy"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Despite the need for it, testing necessarily uses energy. By adding a testing suite to your software you are making the value judgement that the benefits are worth the additional energy cost of running automatic tests."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"But there are ways to mimimize the amount of energy used.\nThe defaults used by most people when adding automated tests to their code base are often wasteful, due to many tests being run when it is not necessary."}]},{"type":"element","tag":"h2","props":{"id":"reduce-energy-waste-from-unnecessary-testing"},"children":[{"type":"text","value":"Reduce energy waste from unnecessary testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the following we address some relatively simple changes that can be made to reduce the unnecessary running of tests.\nThe solutions are given for projects that use "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"pytest"}]},{"type":"text","value":" (the ubiquitous python testing framework) and automation using features of "},{"type":"element","tag":"a","props":{"href":"www.github.com"},"children":[{"type":"text","value":"GitHub"}]},{"type":"text","value":", which is a very common place to host code repositories. However, if you are using a different language (e.g. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":") or you do not use GitHub (maybe GitLab, bitbucket etc) then the general principle should still apply. It may be possible to recreate the same changes by modifying the relevant configuration (we will try to help where we can)."}]},{"type":"element","tag":"h3","props":{"id":"_1-cancel-running-workflows-on-a-new-push"},"children":[{"type":"text","value":"1. Cancel running workflows on a new push"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"By default, it is often the case that currently running tests continue to completion, even if you have pushed new changes to the branch. While that may be desirable in some cases, it is most often not wanted. The user is most interested in whether the newest version of a branch is passing the tests or not."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Luckily, it is possible to "},{"type":"element","tag":"a","props":{"href":"https://docs.github.com/en/enterprise-cloud@latest/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs#example-using-concurrency-and-the-default-behavior","rel":["nofollow"]},"children":[{"type":"text","value":"automatically cancel running tests if new code is pushed to the branch"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h3","props":{"id":"_2-only-re-run-tests-that-failed"},"children":[{"type":"text","value":"2. Only re-run tests that failed"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Use the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"pytest --last-failed"}]},{"type":"text","value":" command by exploiting the gh actions cache functionality using a ready-made github action:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"pytest-last-failed: "},{"type":"element","tag":"a","props":{"href":"https://github.com/sjvrijn/pytest-last-failed","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/sjvrijn/pytest-last-failed"}]}]}]},{"type":"element","tag":"h3","props":{"id":"_3-set-the-workflow-trigger-appropriately-for-each-part-of-the-test-framework"},"children":[{"type":"text","value":"3. Set the workflow trigger appropriately for each part of the test framework"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Test workflows are triggered to run when a particular event happens. To avoid tests running unnecessarily, it is important to ensure that this trigger is set correctly."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Certain test workflows do not need to run on every push, for example, and could be configured to only run on merges to the main branch (or on tagging releases)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows","rel":["nofollow"]},"children":[{"type":"text","value":"GitHub docs on triggering workflows"}]}]},{"type":"element","tag":"h3","props":{"id":"_4-test-on-different-platformsversions-that-make-sense"},"children":[{"type":"text","value":"4. Test on different platforms/versions that make sense"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It is possible to run your automated tests on several platforms (e.g. different versions of Ubuntu, MacOS and Windows) and also on different kinds of software stack (different libraries, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"python"}]},{"type":"text","value":" versions etc.). On GitHub, for example, this can be done using "},{"type":"element","tag":"a","props":{"href":"https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow","rel":["nofollow"]},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"matrix"}]},{"type":"text","value":" strategies"}]},{"type":"text","value":". This is generally desirable, in order to ensure portability across systems."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"However, testing all these combinations comes at a cost. It is important to think about how many users you have (maybe it is just you and some colleagues) and whether what you are testing is actually necessary. For example, supporting every python version from the last 10 years is probably overkill and will waste a lot of energy."}]},{"type":"element","tag":"h3","props":{"id":"_5-create-dependencies-between-tests"},"children":[{"type":"text","value":"5. Create dependencies between tests"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuing to run all tests when one has failed does not always make sense. For example, if a basic linting step has failed, it may be desirable not to run the remaining test suite until that is fixed."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"With GitHub actions this is possible by making dependencies between your jobs: "},{"type":"element","tag":"a","props":{"href":"https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow#example-requiring-successful-dependent-jobs","rel":["nofollow"]},"children":[{"type":"text","value":"see relevant example here"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Alterntively, you may wish to only run the linting tests once the basic tests pass (i.e. no point linting broken code). Which way of adding dependencies is best at reducing unnecessary tests running is dependent on your specific setup."}]},{"type":"element","tag":"h3","props":{"id":"other-toolsplugins-worth-a-look"},"children":[{"type":"text","value":"Other tools/plugins worth a look"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A possible alternative to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"pytest-last-failed"}]},{"type":"text","value":":"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"pytest-testmon: "},{"type":"element","tag":"a","props":{"href":"https://github.com/tarpas/pytest-testmon","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/tarpas/pytest-testmon"}]},{"type":"text","value":", a pytest plugin that only runs tests that concern code that has been affected by changes (interesting but challenging, and possibly unreliable)"}]}]},{"type":"element","tag":"h2","props":{"id":"conclusion"},"children":[{"type":"text","value":"Conclusion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Testing is essential to reducing waste in research software development, but can cause significant energy consumption itself. This is due to the way most testing frameworks are by default configured to run all of the tests, all of the time. By following some or all of the above changes, you can likely save energy by reducing a lot of pointless tests being run."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"testing-is-necessary","depth":2,"text":"Testing is necessary"},{"id":"testing-uses-energy","depth":2,"text":"Testing uses energy"},{"id":"reduce-energy-waste-from-unnecessary-testing","depth":2,"text":"Reduce energy waste from unnecessary testing","children":[{"id":"_1-cancel-running-workflows-on-a-new-push","depth":3,"text":"1. Cancel running workflows on a new push"},{"id":"_2-only-re-run-tests-that-failed","depth":3,"text":"2. Only re-run tests that failed"},{"id":"_3-set-the-workflow-trigger-appropriately-for-each-part-of-the-test-framework","depth":3,"text":"3. Set the workflow trigger appropriately for each part of the test framework"},{"id":"_4-test-on-different-platformsversions-that-make-sense","depth":3,"text":"4. Test on different platforms/versions that make sense"},{"id":"_5-create-dependencies-between-tests","depth":3,"text":"5. Create dependencies between tests"},{"id":"other-toolsplugins-worth-a-look","depth":3,"text":"Other tools/plugins worth a look"}]},{"id":"conclusion","depth":2,"text":"Conclusion"}]}},"_type":"markdown","_id":"local_fs:modules:software-development-handson:exercises_cicd.md","_source":"local_fs","_file":"modules/software-development-handson/exercises_cicd.md","_stem":"modules/software-development-handson/exercises_cicd","_extension":"md","plainText":"---\ntitle: CI/CD optimization\ntype: exercise\norder: 4\n---\n\n# Make your automated testing framework use less energy\n\n## Testing is necessary\nA robust testing framework is an essential part of good software development practices. It is even more vital in a research environment since wrong or misleading scientific results may be caused by bad or insufficient testing. Automated testing aids in scientific reproducibility and reduces the amount of time wasted trying to go back to find which version still worked with a given feature.\n\nIf you are unsure about what a testing framework is or how to set one up, you can learn about it in the [Good Practices](exercises_good-practices) exercises of this hands-on module (specifically, it is [step 4](exercises_good-practices#_4-testing). Adding tests to your scientific code is a good step towards avoiding wasted energy in the long run.\n\n\n## Testing uses energy\nDespite the need for it, testing necessarily uses energy. By adding a testing suite to your software you are making the value judgement that the benefits are worth the additional energy cost of running automatic tests.\n\nBut there are ways to mimimize the amount of energy used.\nThe defaults used by most people when adding automated tests to their code base are often wasteful, due to many tests being run when it is not necessary.\n\n## Reduce energy waste from unnecessary testing\nIn the following we address some relatively simple changes that can be made to reduce the unnecessary running of tests.\nThe solutions are given for projects that use `pytest` (the ubiquitous python testing framework) and automation using features of [GitHub](www.github.com), which is a very common place to host code repositories. However, if you are using a different language (e.g. `R`) or you do not use GitHub (maybe GitLab, bitbucket etc) then the general principle should still apply. It may be possible to recreate the same changes by modifying the relevant configuration (we will try to help where we can).\n\n### 1. Cancel running workflows on a new push\nBy default, it is often the case that currently running tests continue to completion, even if you have pushed new changes to the branch. While that may be desirable in some cases, it is most often not wanted. The user is most interested in whether the newest version of a branch is passing the tests or not.\n\nLuckily, it is possible to [automatically cancel running tests if new code is pushed to the branch](https://docs.github.com/en/enterprise-cloud@latest/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs#example-using-concurrency-and-the-default-behavior).\n\n### 2. Only re-run tests that failed\nUse the `pytest --last-failed` command by exploiting the gh actions cache functionality using a ready-made github action:\n* pytest-last-failed: <https://github.com/sjvrijn/pytest-last-failed>\n\n### 3. Set the workflow trigger appropriately for each part of the test framework\nTest workflows are triggered to run when a particular event happens. To avoid tests running unnecessarily, it is important to ensure that this trigger is set correctly.\n\nCertain test workflows do not need to run on every push, for example, and could be configured to only run on merges to the main branch (or on tagging releases).\n\n[GitHub docs on triggering workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows)\n\n\n### 4. Test on different platforms/versions that make sense\nIt is possible to run your automated tests on several platforms (e.g. different versions of Ubuntu, MacOS and Windows) and also on different kinds of software stack (different libraries, `python` versions etc.). On GitHub, for example, this can be done using [`matrix` strategies](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow). This is generally desirable, in order to ensure portability across systems.\n\nHowever, testing all these combinations comes at a cost. It is important to think about how many users you have (maybe it is just you and some colleagues) and whether what you are testing is actually necessary. For example, supporting every python version from the last 10 years is probably overkill and will waste a lot of energy.\n\n\n### 5. Create dependencies between tests\n\nContinuing to run all tests when one has failed does not always make sense. For example, if a basic linting step has failed, it may be desirable not to run the remaining test suite until that is fixed.\n\nWith GitHub actions this is possible by making dependencies between your jobs: [see relevant example here](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow#example-requiring-successful-dependent-jobs).\n\nAlterntively, you may wish to only run the linting tests once the basic tests pass (i.e. no point linting broken code). Which way of adding dependencies is best at reducing unnecessary tests running is dependent on your specific setup.\n\n\n### Other tools/plugins worth a look\n\nA possible alternative to `pytest-last-failed`:\n* pytest-testmon: <https://github.com/tarpas/pytest-testmon>, a pytest plugin that only runs tests that concern code that has been affected by changes (interesting but challenging, and possibly unreliable)\n\n\n## Conclusion\nTesting is essential to reducing waste in research software development, but can cause significant energy consumption itself. This is due to the way most testing frameworks are by default configured to run all of the tests, all of the time. By following some or all of the above changes, you can likely save energy by reducing a lot of pointless tests being run.\n\n"}